{% set newline = "\n" -%}
from __future__ import annotations

from typing import Any, Dict, List

from google.adk.agents import Agent, LoopAgent, SequentialAgent

from models.state_model import WorkflowState
from tools.mcp_client import call_mcp_tool

DEFAULT_MODEL = "{{ model }}"
BASE_REACT_INSTRUCTION = """You operate inside a generated ReAct workflow. Follow this loop:
1. Reason step-by-step about the assigned node.
2. Decide whether to call `call_mcp_tool` (mocked MCP).
3. Observe the tool result and refine your plan.
4. Stop when your response contains 'OK'.

Persist helpful context inside session state via callbacks or tool outputs."""

GRAPH_DEFINITION: Dict[str, Any] = {
    "nodes": {{ nodes | pprint }},
    "edges": {{ edges | pprint }},
    "order": {{ ordered_node_ids | pprint }},
}

SELECTOR_ROUTES: Dict[str, List[Dict[str, str]]] = {
{% for selector_id, routes in selector_routes.items() %}
    "{{ selector_id }}": {{ routes | pprint }},
{% endfor %}
}


def build_instruction(label: str, node_id: str) -> str:
    return BASE_REACT_INSTRUCTION + f"\nCurrent node ({node_id}): {label}."


class SelectorAgent:
    """Documentation-first placeholder describing conditional routes.

    Real branching happens via shared session state and the surrounding
    SequentialAgent ordering, but keeping this structure makes it easy to
    replace with an ADK-native Router in the future.
    """

    def __init__(self, name: str, routes: List[Dict[str, str]]):
        self.name = name
        self.routes = routes

    def as_dict(self) -> Dict[str, List[Dict[str, str]]]:
        return {"name": self.name, "routes": self.routes}


workflow_state = WorkflowState().to_dict()

# === Auto-generated Agent Definitions ===
{% for node in nodes %}
{{ node.var_name }} = Agent(
    name="{{ node.id.lower() }}",
    model=DEFAULT_MODEL,
    description="Auto-generated step for {{ node.label }}",
    instruction=build_instruction("{{ node.label }}", "{{ node.id }}"),
    tools=[call_mcp_tool],
)
{% if node.loop %}
{{ node.var_name }}_loop = LoopAgent(
    name="{{ node.id.lower() }}_loop",
    description="Loop wrapper for {{ node.label }}",
    sub_agents=[{{ node.var_name }}],
    max_iterations=5,
)
{% endif %}
{% endfor %}

node_registry = {
{% for node in nodes %}
    "{{ node.id }}": {{ node.var_name }}{% if node.loop %}_loop{% endif %},
{% endfor %}
}

selector_registry = {
{% for selector_id, routes in selector_routes.items() %}
    "{{ selector_id }}": SelectorAgent(
        name="{{ selector_id.lower() }}_selector",
        routes={{ routes | pprint }},
    ),
{% endfor %}
}

workflow_sequence = [
{% for node_id in ordered_node_ids %}
    node_registry["{{ node_id }}"],
{% endfor %}
]

root_agent = SequentialAgent(
    name="generated_workflow",
    description="Workflow compiled from Mermaid flowchart.",
    sub_agents=workflow_sequence,
)
